mod body;
pub mod configuration;

pub use configuration::Configuration;
pub use url::Url;
use configuration::BoxedError;

use std::ops::Deref;
use std::{error, fmt, sync::Arc};

#[derive(Clone)]
pub struct ApiClient {
{{#apiInfo}}
{{#apis}}
{{#operations}}
    {{{classFilename}}}: Box<dyn crate::apis::{{{classFilename}}}::tower::client::{{{classname}}}>,
{{/operations}}
{{/apis}}
{{/apiInfo}}
}

impl ApiClient {
    pub fn new(configuration: Configuration) -> ApiClient {
        let rc = Arc::new(configuration);

        ApiClient {
{{#apiInfo}}
{{#apis}}
{{#operations}}
            {{^-last}}
            {{{classFilename}}}: Box::new(crate::apis::{{{classFilename}}}::tower::client::{{{classname}}}Client::new(rc.clone())),
            {{/-last}}
            {{#-last}}
            {{{classFilename}}}: Box::new(crate::apis::{{{classFilename}}}::tower::client::{{{classname}}}Client::new(rc)),
            {{/-last}}
{{/operations}}
{{/apis}}
{{/apiInfo}}
        }
    }

{{#apiInfo}}
{{#apis}}
{{#operations}}
    pub fn {{{classFilename}}}(&self) -> &dyn crate::apis::{{{classFilename}}}::tower::client::{{{classname}}} {
        self.{{{classFilename}}}.as_ref()
    }
{{/operations}}
{{/apis}}
{{/apiInfo}}
}

/// Http Response with status and body
#[derive(Debug, Clone)]
pub struct ResponseContent<T> {
    pub(crate) status: hyper::StatusCode,
    pub(crate) body: T,
}
impl<T> ResponseContent<T> {
    /// Get the status code
    pub fn status(&self) -> hyper::StatusCode {
        self.status
    }
    /// Get a reference to the body
    pub fn body(&self) -> &T {
        &self.body
    }
    /// Convert self into the body
    pub fn into_body(self) -> T {
        self.body
    }
}

/// Http Response with status and body as text (could not be coerced into the expected type)
#[derive(Debug, Clone)]
pub struct ResponseContentUnexpected {
    pub(crate) status: hyper::StatusCode,
    pub(crate) text: String,
}
impl ResponseContentUnexpected {
    /// Get the status code
    pub fn status(&self) -> hyper::StatusCode {
        self.status
    }
    /// Get a reference to the text
    pub fn text(&self) -> &str {
        self.text.as_ref()
    }
}

/// Error type for all Requests with the various variants
#[derive(Debug)]
pub enum Error<T> {
    Request(RequestError),
    Response(ResponseError<T>),
}
impl<T> From<RequestError> for Error<T> {
    fn from(src: RequestError) -> Self {
        Self::Request(src)
    }
}
impl<T> From<ResponseError<T>> for Error<T> {
    fn from(src: ResponseError<T>) -> Self {
        Self::Response(src)
    }
}

/// Failed to issue the request
#[derive(Debug)]
pub enum RequestError {
    /// Failed to build the http request
    BuildRequest(hyper::http::Error),
    /// Service Request call returned an error
    Request(BoxedError),
    /// Service was not ready to process the request
    NotReady(BoxedError),
    /// Failed to serialize request payload
    Serde(serde_json::Error),
    /// Failed to encode the url path
    SerdeEncoded(serde_urlencoded::ser::Error),
}

/// Error type for all Requests with the various variants
#[derive(Debug)]
pub enum ResponseError<T> {
    /// The OpenAPI call returned the "expected" OpenAPI JSON content
    Expected(ResponseContent<T>),
    /// Failed to convert the response payload to bytes
    PayloadError {
        status: hyper::StatusCode,
        error: hyper::Error,
    },
    /// The OpenAPI call returned an "unexpected" JSON content
    Unexpected(ResponseContentUnexpected),
}

impl<T: fmt::Debug> fmt::Display for Error<T> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let (module, e) = match self {
            Error::Request(r) => match r {
                RequestError::BuildRequest(e) => ("build_request", e.to_string()),
                RequestError::Request(e) => ("request", e.to_string()),
                RequestError::NotReady(e) => ("not_ready", e.to_string()),
                RequestError::Serde(e) => ("serde", e.to_string()),
                RequestError::SerdeEncoded(e) => ("serde_encoding", e.to_string()),
            },
            Error::Response(r) => match r {
                ResponseError::Expected(e) => (
                    "response",
                    format!("status code '{}', content: '{:?}'", e.status, e.body),
                ),
                ResponseError::PayloadError { status, error } => (
                    "response",
                    format!("status code '{}', error: '{:?}'", status, error),
                ),
                ResponseError::Unexpected(e) => (
                    "response",
                    format!("status code '{}', text '{}'", e.status, e.text),
                ),
            },
        };
        write!(f, "error in {}: {}", module, e)
    }
}

impl<T: fmt::Debug> error::Error for Error<T> {
    fn source(&self) -> Option<&(dyn error::Error + 'static)> {
        Some(match self {
            Error::Request(r) => match r {
                RequestError::BuildRequest(e) => e,
                RequestError::Request(e) => e.deref(),
                RequestError::NotReady(e) => e.deref(),
                RequestError::Serde(e) => e,
                RequestError::SerdeEncoded(e) => e,
            },
            Error::Response(r) => match r {
                ResponseError::Expected(_) => return None,
                ResponseError::PayloadError { error, .. } => error,
                ResponseError::Unexpected(_) => return None,
            },
        })
    }
}
